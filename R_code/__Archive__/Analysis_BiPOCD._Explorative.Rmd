---
  title: "Analysis of BiPOCD data"
author: "Sebastian Sauer"
date: "4 Juli 2016"
output:
  html_document:
  toc: yes
toc_depth: 3
number_sections: true
---

  ```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, cache = TRUE, warning = FALSE, message = FALSE)

library(mosaic)
library(readr)
#library(stringr)
#library(ggvis)
#library(pander)
library(purrr)
library(caret)
library(broom)
library(psych)
#library(ggstance)
library(knitr)
library(gridExtra)
library(tibble)
library(corrplot)
library(GGally)
library(dplyr)
library(ggplot2)
library(tidyr)
library(gridExtra)
library(DiagrammeR)



# define paths
path_data <- "~/Documents/OneDrive/Forschung/Online_Behavior_Therapy/raw_data"
path_file_data <- "~/Documents/OneDrive/Forschung/Online_Behavior_Therapy/raw_data/BiPOCD_raw_data.csv"
path_code <- "~/Documents/OneDrive/Forschung/Online_Behavior_Therapy/R_code"
path_figs <- "~/Documents/OneDrive/Forschung/Online_Behavior_Therapy/Figures"
path_obj <- "~/Documents/OneDrive/Forschung/Online_Behavior_Therapy/data_objects"

# load data
data <- read_csv(path_file_data)


# constants
red1 <- "#880011"
```




```{r funs}

gg_bar <- function(x, ...){
  {
    ggplot(data_frame(x), aes(x = x)) +
      geom_bar() +
      coord_flip()
  }
}


add_na_col <- function(x){
  mutate(x, na = 0)
}

has_n_col <- function(x, n = 6){
  return(ncol(x) == n)
}



tally_OR <- function(x, data = data_comorb){
  tab <- mosaic::tally(x ~ responder_3m, data = data_comorb)
  oddsRatio(tab)
}


tally_RR <- function(x, data = data_comorb){
  tab <- mosaic::tally(x ~ responder_3m, data = data_comorb)
  relrisk(tab)
}

tally_fun <- function(x, data = data_comorb, fun = fun){
  tab <- mosaic::tally(x ~ responder_3m, data = data_comorb)
  fun(tab)
}


```



# First glimpse

```{r}
glimpse(data)
```


##  Variable names
The main (raw) data file has a dimension of `r dim(data)` (rows*cols). The col names are:

  ```{r}
names(data)
```

# Overviews
## Summaries of quantitative variables

```{r}


data %>%
  select_if(is.numeric)  %>%
  lapply(., function(x) tidy(summary(x))) %>%   # compute tidy summary of each var
  map_if(., has_n_col, add_na_col) %>%   # add na-col if missing
  do.call(rbind, .) -> sum_num  # bind list elements into df

kable(sum_num)

```


## Histograms of quantitative variables **

```{r histograms_numeric, cache = TRUE, fig.height = 100}
data %>%
  select_if(is.numeric) %>%
  gather(key = variable, value = value) %>%
  ggplot(aes(x = value)) +
  geom_histogram() +
  facet_wrap(~variable, scales = "free", ncol = 4)

```


## Histogram of non-numeric variables

```{r, cache = TRUE}



data %>%
  select_if(negate(is.numeric)) %>%
  lapply(., function(x) gg_bar(x)) -> gg_bar_list

do.call(grid.arrange, gg_bar_list)
```


## Check for (near) zero variance (nz/nzv) variables

Predictors without (much) variance do not add to the model. Better exclude them, at least know them.

```{r}
data %>%
  select(-ID) %>%
  nearZeroVar(., saveMetrics = TRUE) %>%
  pander

data %>%
  nearZeroVar(., saveMetrics = TRUE) %>%
  rownames_to_column() %>%
  filter(nzv == TRUE) -> data_nzv

nzv_vars <- data_nzv$rowname


pander(data_nzv)

```

The variables with near zero variance are `r nzv_vars`.

## Check for highly correlated variables
Highly correlated (>.90) do not provide more information, better exclude them.

```{r}

data %>%
  select_if(is.numeric) %>%
  cor -> data_cor

highCorr <- sum(abs(data_cor[upper.tri(data_cor)]) > .90)
highCorr
```

No variables are highly correlated (>.90) in this dataset.


## Missing values

```{r}
sum_num %>%
  select(na) %>%
  rownames_to_column %>%
  filter(na != 0) %>%
  ggplot(aes(x  = rowname, y = na, label = na)) + geom_bar(stat = "identity") +
  coord_flip() +
  ggtitle("Number of missing values per variable")
```



## Checking Scale quality

Scale quality involves aspects as intercorrelation of items of a scale, internal consisteny, score distribution, and the like. Let's see.

### Correlation of comorbidity


If one suffers from one comorbidity, does he/she suffer (in general) from other comorbidities too? NZV variables are excluded.

```{r, cache = TRUE, fig.height = 6}


data %>%
select(Depression:GAD) %>%
select(-one_of(nzv_vars)) %>%
cor -> cor_comorb

corrplot(cor_comorb)


```


We should do this more stringently, but let's start with a brief look to the items of `ChOCI`, to see whether they are correlated (as they should be, at least for common subscale-items). Those are quite a few.
```{r, warning = FALSE, fig.height = 50}

data %>%
  dplyr::select(dplyr::contains("ChOCI")) %>%
  select(-one_of(nzv_vars)) %>%
  cor %>%
  corrplot

```


### ChOCI


```{r, warning = FALSE}
data %>%
  dplyr::select(dplyr::contains("ChOCI")) %>%
  select(-one_of(nzv_vars))  -> ChOCI_items

psych::alpha(ChOCI_items, check.keys = TRUE)

```

One item was **negatively** correlated with the scale (`ChOCI_R_C_26_PRE-`). It should be checked.
***

  ```{r}
search_string <- "ChOCI"

data %>%
  dplyr::select(ChOCI_R_C_sumsym_PRE, ChOCI_R_C_sumimp_PRE)) %>%
  gather %>%
  ggplot(ggplot2::aes(x = value)) + geom_density() +
  facet_wrap(~ key)
```



# Bivariate assocations

## Associations with treatment response

### Comorbidity as predictors


```{r}
data %>%
  select(Depression:GAD, responder_3m) %>%
  select(-one_of(nzv_vars)) %>%
  na.omit -> data_comorb


comorb_OR <-
  lapply(select(data_comorb, -responder_3m),
         function(x) tally_OR(x))

comorb_RR <-
  lapply(select(data_comorb, - responder_3m),
         function(x) tally_RR(x))
```

The (non-nzv) comorbities are: `r names(data_comorb)[-8]`. The Odds ratios of the comorbities with the outcome variable are: `r lapply(comorb_OR, function(x) round(x, 2))`.

The relative risks of the comorbities with the outcome variable are: `r lapply(comorb_RR, function(x) round(x, 2))`.


```{r}

# relative risks:
comorb_RR_df <- data_frame(comorb_diag = names(comorb_RR),
                           RelRisk = unlist(comorb_RR))



comorb_RR_df %>%
  ggplot(aes(x = reorder(comorb_diag, RelRisk), y = RelRisk)) + geom_point() +
  coord_flip() +
  ggtitle("Relative Risks of comorbity diagnoses")


# odds ratios:
comorb_OR_df <- data_frame(comorb_diag = names(comorb_OR),
                           OR = unlist(comorb_OR))

comorb_OR_df %>%
  ggplot(aes(x = reorder(comorb_diag, OR), y = OR)) + geom_point() +
  coord_flip() +
  ggtitle("Odds Ratio of comorbity diagnoses")
```



Let's plot the assocation of the comorbitity with the outcome var `responder_3m`. To that end, let's tabulate the the 2x2 matrices (contingency matrices) for each comorbidity (yes/no) vs. responder (yes/no). For convenience, proportions (%) are depicted.

```{r}

for (i in seq_along(names(data_comorb))){
  my_tab <- prop.table(table(data_comorb[[i]], data_comorb$responder_3m))
  my_tab <- round(my_tab, 2)
  comorb <- names(data_comorb)[i]
  print(comorb)
  print(my_tab)
  mosaicplot(my_tab, ylab = comorb, xlab = "responder_3m")
}

```



Wait a minute, it looks as if there a few persons where `responder_3m == 1`! Does that mean, most participants did not respond (ie., no success)?


```{r}

data %>%
  ggplot(aes(x = factor(responder_3m))) + geom_bar() +
  geom_text(stat = "count", aes(label = ..count..), vjust = -1)

```


Hm, let's divide that up for each comorbidity, and plot it:

```{r}
data %>%
select(Depression:GAD, responder_3m) %>%
gather(key, value, -responder_3m) %>%
ggplot(aes(x = factor(key))) + geom_bar() +
facet_wrap(~responder_3m) +
coord_flip() +
ggtitle("Break up of responder (yes=1/no=0) by comorbidity")

```

Hoaza! That looks strange! Can that be? Surely there must be some bug, either in my code, what may well be the case (Deus adiuvet me), or in the data.

Let's look at it from some other perspective, different code, and plot it again, and see what happens:

  ```{r}

data %>%
  select(Depression:GAD, responder_3m) %>%
  transform(responder_3m = factor(responder_3m)) %>%
  gather(key, value, -responder_3m) %>%
  group_by(key, responder_3m) %>%
  summarise(n = n()) %>%
  ggplot(aes(x = responder_3m, y = n)) + geom_bar(stat = "identity") +
  facet_wrap(~key) +
  coord_flip()
```


And what it about if we eyeball the plain number:

  ```{r}
data %>%
  select(Depression:GAD, responder_3m) %>%
  transform(responder_3m = factor(responder_3m)) %>%
  gather(key, value, -responder_3m) %>%
  group_by(key, responder_3m) %>%
  summarise(n = n()) %>%
  pander
```


Hm, the same picture emerges: **With** comorbidity *always* 23 cases, **without** comorbidity also 33 cases. Somewhere there must be a bug...


# Most important variables (narrow data set)

## Type of most important variables

Let's focus on the most important variables, to make life easier.

That should be all sum scores. Let's look for them:

  ```{r}

search_string <- "sum"
data %>%
  dplyr::select(matches(search_string)) %>%
  do(tidy(names(.))) -> names_sumscores

```

Ok, the variables are `r names_sumscores$x`. In total, `r nrow(names_sumscores)` variables.

We can probably safely ignore `ID`. We should include basic and demographic variables:

  ```{r}
data %>%
  dplyr::select(group:OCD_treatm_exp, responder_3m, CYBOCS_3m) %>%
  do(tidy(names(.))) -> names_basic
```

Which gives us `r names_basic$x`, another `r nrow(names_basic)` variables.

Of particular interest are of course `responder_3m`, `CYBOCS_3m` (outcomes) and `group` (experimental factor).

Next, let's name the comorbidities.

```{r}
data %>%
select(Depression:GAD) %>%
do(tidy(names(.))) -> names_comorb
```

These are `r names_comorb$x`.

In total, 3 sets of variables then: basic variables (including outcome and experimental variables), sum scores of psychometric battery, and comorbidity.

```{r}
vars_short <- unname(unlist(c(names_basic, names_sumscores, names_comorb)))
```

In total, `r length(vars_short)` Variables: `r vars_short`.


## Coarse model

Vague defined, the model can be described as consisting of these predictors: demographics, psychometric scales, treatment (group), comorbities. The outcome is treatment response.


```{r}
grViz("
digraph test {

# a 'graph' statement
graph [overlap = true,
rankdir = LR,
fontsize = 10]

# several 'node' statements
node [shape = circle,
fontname = Helvetica]
demographics; scales; comorbidities; response; treatment


# several 'edge' statements
demographics -> response
scales -> response
comorbidities -> response
treatment -> response

}
")
```



## Missing values and sum scores
When tallying up sum scores, missing values cause problems. Assume 10 items to summed up. What if I have not responded to 9 items? If you count "zero" for the missing values, you will dramatically underestimate my true score. I wonder how the sum scores have been built here.


### ChOCI scale (self-rated comorbidity)

The most items appear in the `ChOCI` scale. So let's look there first.


```{r}
search_string <- "ChOCI"
data %>%
  select(matches(search_string)) %>%
  summarise_all(funs(sum(is.na(.)))) %>%
  gather(item, n_na) %>%
  kable

```


Ok, good, no missings. Have they been replaced somehow? Where the participants forced to give some answer? This might be of interest for gauging the psychometric quality of the scale.


### CYBOCS OCD symptoms


```{r}
search_string <- "CYBOCS"
data %>%
  select(matches(search_string)) %>%
  summarise_all(funs(sum(is.na(.)))) %>%
  gather(item, n_na) %>%
  kable
```


Hm, here we find some missing values. So what was done to prevent bias here? We should follow up on that.



### EWSASC (functioning)

Same procedure...

```{r}
search_string <- "EWSASC"
data %>%
  select(matches(search_string)) %>%
  summarise_all(funs(sum(is.na(.)))) %>%
  gather(item, n_na) %>%
  kable

```

Ok, no NA's.


### SCAS (Anxiety)

```{r}
search_string <- "SCAS"
data %>%
select(matches(search_string)) %>%
summarise_all(funs(sum(is.na(.)))) %>%
gather(item, n_na) %>%
kable

```

No NA's.


### CDI (Depression)


```{r}
search_string <- "CDI"
data %>%
  select(matches(search_string)) %>%
  summarise_all(funs(sum(is.na(.)))) %>%
  gather(item, n_na) %>%
  kable
```

No NA's.


### FAS (family accomodation)

```{r}

search_string <- "FAS"
data %>%
select(matches(search_string)) %>%
summarise_all(funs(sum(is.na(.)))) %>%
gather(item, n_na) %>%
kable
```

No NA's.

### EWSASP (functioning, 2nd scale)

```{r}


search_string <- "EWSASP"
data %>%
  select(matches(search_string)) %>%
  summarise_all(funs(sum(is.na(.)))) %>%
  gather(item, n_na) %>%
  kable
```

No NA's.



### SCAS (Anxiety)


```{r}


search_string <- "SCAS"
data %>%
select(matches(search_string)) %>%
summarise_all(funs(sum(is.na(.)))) %>%
gather(item, n_na) %>%
kable
```


No NA's.


# Interocular Trauma Test

## Outcome: responder_3m

Before applying some sophisticated (aka esoteric) models, let's perform the _intraocular trauma test_ for the data: let's see whether the effect is so crisp that it hits us right between the eyes. That is., is there an association between group and response?


Because for the fun of it (and because the question if of particular interest), let's plot from different point of views.

```{r trauma_test_1}

data %>%
select(group, responder_3m) %>%
mutate(responder_3m = factor(responder_3m)) %>%
group_by(group, responder_3m) %>%
summarise(n = n()) %>%
ggplot(aes(x = group, y = n, fill = responder_3m)) + geom_bar(stat = "identity")


data %>%
select(group, responder_3m) %>%
mutate(responder_3m = factor(responder_3m)) %>%
group_by(group, responder_3m) %>%
summarise(n = n()) %>%
ggplot(aes(x = group, y = n)) + geom_bar(stat = "identity")  +
facet_wrap(~responder_3m)


data %>%
select(group, responder_3m) %>%
mutate(responder_3m = factor(responder_3m)) %>%
group_by(group, responder_3m) %>%
summarise(n = n()) %>%
ggplot(aes(x = group, y = n, fill = responder_3m)) + geom_bar(stat = "identity", position = "fill")


```


Hm, it appears as if the experimental group was less successful than the control group. That result might hit us between the eyes... But one would certainly hope for something the other way round.

The bare numbers:

```{r}
data %>%
select(group, responder_3m) %>%
mutate(responder_3m = factor(responder_3m)) %>%
group_by(group, responder_3m) %>%
summarise(n = n()) %>%
kable
```


## Outcome: CYBOCS_3m

```{r trauma_test_2}

data %>%
select(group, CYBOCS_3m) %>%
na.omit() %>%
ggplot(aes(x = group, y = CYBOCS_3m))  +
geom_boxplot() +
geom_jitter(width = .1) +
stat_summary(fun.y = "mean", geom = "point", size = 6, color = "red")

data %>%
select(group, CYBOCS_3m) %>%
na.omit() %>%
ggplot(aes(fill = group, x = CYBOCS_3m, color = group))  +
geom_density(alpha = .5)


```


For this outcome, it seems as if there was some (slight?) advantage for the treatment group. However, the overlap is substantial.

Here come the bare figures:

```{r}
data %>%
dplyr::select(group, CYBOCS_3m, -one_of(nzv_vars)) %>%
na.omit() %>%
group_by(group) %>%
summarise(group_mean = mean(CYBOCS_3m),
group_md = median(CYBOCS_3m),
group_sd = sd(CYBOCS_3m),
group_IQR = IQR(CYBOCS_3m)) %>%
kable
```





